{"cell_type":"code","exec_count":193,"id":"b8efd7","input":"def expon_list(size = 1, scale = 1):\n    prob_list = sorted(np.array([(1/scale)*expon.pdf(x/scale) for x in range(size)]))\n    normed_list = prob_list/sum(prob_list)\n    return normed_list","pos":3,"type":"cell"}
{"cell_type":"code","exec_count":199,"id":"9b6591","input":"def compute_slices(max = MAXSLICES, pizza_list = PIZZAS):\n    final_list = []\n    while (max >= 0):\n      admissible_pizzas = [pizza for pizza in pizza_list if pizza <= max]\n      if admissible_pizzas:\n        num_pizzas = len(admissible_pizzas)\n        prob_list = create_prob_list(size=num_pizzas, dist=np.random.exponential, scale = 0.0001)\n        index = np.random.choice(num_pizzas,p=prob_list)\n        rand_pizza = admissible_pizzas.pop(index)\n        pizza_list = admissible_pizzas\n        max = max - rand_pizza\n        final_list.append(rand_pizza)\n      else:\n        break\n    return final_list","pos":5,"type":"cell"}
{"cell_type":"code","exec_count":2,"id":"136472","input":"with open('data/d_quite_big.in') as file:\n    data = file.read().split()\n\ndata = [int(_) for _ in data]\nMAXSLICES = data[0]\nTYPES = data[1]\nPIZZAS = data[2:]\npizza_indices = {pizza: index for index, pizza in enumerate(PIZZAS)}","pos":1,"type":"cell"}
{"cell_type":"code","exec_count":239,"id":"90dc04","input":"Mama_Mia_Its_A_Pizza = sorted([pizza_indices[p] for p in best_output])","pos":7,"type":"cell"}
{"cell_type":"code","exec_count":278,"id":"999a90","input":"def all_slices(pizza_list):\n    possible_slices = sorted([sum(comb) for k in range(1,len(pizza_list)+1) for comb in combowombo(pizza_list,k)])\n    return possible_slices","pos":4,"type":"cell"}
{"cell_type":"code","exec_count":436,"id":"7757d7","input":"collected_prob = []","pos":8,"type":"cell"}
{"cell_type":"code","exec_count":465,"id":"a82189","input":"len(collected_prob)","output":{"0":{"data":{"text/plain":"37"},"exec_count":465,"output_type":"execute_result"}},"pos":10,"type":"cell"}
{"cell_type":"code","exec_count":471,"id":"40ee65","input":"collected_prob.extend(record_prob)\ntd = pd.DataFrame(collected_prob)\ntd.plot.hist(bins=30)","output":{"0":{"data":{"text/plain":"<matplotlib.axes._subplots.AxesSubplot at 0x1615429e080>"},"exec_count":471,"output_type":"execute_result"},"1":{"data":{"image/png":"587862da9e428193e99970c3c08085348e18d02e","image/svg+xml":"70984e16cb206de06d82e4f315441c64969e9cdb","text/plain":"<Figure size 432x288 with 1 Axes>"},"metadata":{"needs_background":"light"},"output_type":"display_data"}},"pos":9,"type":"cell"}
{"cell_type":"code","exec_count":490,"id":"d6acbc","input":"import numpy as np\nimport pandas as pd\nfrom scipy.stats import expon\nfrom scipy import stats\nfrom itertools import combinations as combowombo\nimport matplotlib.pyplot as plt","pos":0,"type":"cell"}
{"cell_type":"code","exec_count":513,"id":"c06056","input":"c = stats.weibull_min.fit(collected_prob)\nc","output":{"0":{"data":{"text/plain":"(0.37092422645806417, 0.9999999999999998, 123.10468657765978)"},"exec_count":513,"output_type":"execute_result"}},"pos":11,"type":"cell"}
{"cell_type":"code","exec_count":514,"id":"308d1d","input":"x = np.linspace(0,1000, 100)\nW = stats.weibull_min(*c)\nplt.plot(x,W.pdf(x))\n","output":{"0":{"data":{"text/plain":"[<matplotlib.lines.Line2D at 0x1615ac84438>]"},"exec_count":514,"output_type":"execute_result"},"1":{"data":{"image/png":"44d9b8d6afc44b0d12a05a5d8fc6426394fd2eb8","image/svg+xml":"752c4fcc5c8e010b032896b59ce3262ebae90d30","text/plain":"<Figure size 432x288 with 1 Axes>"},"metadata":{"needs_background":"light"},"output_type":"display_data"}},"pos":12,"type":"cell"}
{"cell_type":"code","exec_count":515,"id":"74139f","input":"MAX = 385749466\nbest_output = []\nbest_total = 0\n\nif MAX < 5E6:\n    reps = 100000\nelif MAX < 50E6:\n    reps = 10000\nelif MAX < 500E6:\n    reps = 1000\nelse:\n    reps = 100\n\n#I collected some data on how long a particular best solution survives for and modeled it with a Weibull distribution.\n#I computed the relative liklihood that the best solution would survive 42 more rounds given it survived until time T.\n#If a solution survives 420 rounds, there is an 78% chance that it will survive 42 more rounds. This was good enough for me to call it\n#a winner early. This avoids situations where it is actually impossible to make the MAXSLICES. Yes, I did all this for a joke, but also,\n#It's efficient! Ish.\n\n#record_prob = []\ncounter = 0\n\nfor i in range(reps):\n    if best_total == MAX:\n        break\n    if counter >= 420:\n        break\n    output = compute_slices(max = MAX)\n    total = sum(output)\n    if total > best_total:\n        best_total = total\n        best_output = output\n        #if counter:\n        #    record_prob.append(counter)\n        counter = 0\n    else:\n        counter += 1\n        \nprint(f'Total = {best_total} \\ndiff = {MAX - best_total}')","output":{"0":{"name":"stdout","output_type":"stream","text":"Total = 385749466 \ndiff = 0\n"}},"pos":6,"type":"cell"}
{"cell_type":"code","exec_count":96,"id":"9a6398","input":"def create_sorted_prob_list(size = 1, dist = np.random.uniform, **kwargs):\n    prob_list = sorted(dist(size = size, **kwargs))\n    total = sum(prob_list)\n    prob_list = prob_list/total\n    return prob_list","pos":2,"type":"cell"}
{"cell_type":"code","id":"eceb87","input":"","pos":13,"type":"cell"}
{"kernel":"python37364bit60048d0b48ed47279bce78137ce80676","metadata":{"file_extension":".py","language_info":{"codemirror_mode":{"name":"ipython","version":3},"name":"python","version":"3.7.3-final"},"mimetype":"text/x-python","name":"python","npconvert_exporter":"python","orig_nbformat":2,"pygments_lexer":"ipython3","version":3},"trust":true,"type":"settings"}
{"last_load":1580685995103,"type":"file"}